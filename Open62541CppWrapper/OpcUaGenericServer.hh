//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------

#ifndef OPCUAGENERICSERVER_HH_
#define OPCUAGENERICSERVER_HH_

#include <map>
#include <string>

#ifdef HAS_OPCUA
	#include <open62541/server.h>
#endif

#include "OpcUaStatusCode.hh"
#include "OpcUaVariant.hh"
#include "OpcUaNodeId.hh"

namespace OPCUA {

class GenericServer {
private:
#ifdef HAS_OPCUA
	UA_ServerConfig *config;
	UA_Server *server;
	NodeId rootObjectId;
#endif // HAS_OPCUA

	// make the GenericServer non-copyable
	GenericServer(const GenericServer&) = delete;
	GenericServer& operator=(const GenericServer&) = delete;

	/** this method is used by the Constructor to create the root object
	 *
	 *  This method wraps the code to create a default server object under the default
	 *  objects folder using the given objectName. Optionally the namespace index can be
	 *  specified (default is 1).
	 *
	 *  @param objectName the name of the object which will result in the browse and the display names
	 *  @param namespaceId optional parameter to specify the namespace index
	 *
	 *  @return true if object has been created successfully of false otherwise
	 */
	bool createRootObject(const std::string &objectName, const unsigned short &namespaceId=1);

protected:

	/** use this method from within createServerSpace() to add an OPC UA variable to the internal server space
	 *
	 *  This method wraps the code to create and add a new OPC UA variable to the internally created
	 *  rootObject using the given nodeName. In addition, the created variable is initialized
	 *  with the provided initialValue. The variable can be either readOnly (default) or read+write otherwise.
	 *  Optionally the namespace index can be specified (default is 1).
	 *
	 *  @param nodeName the name of the variable which will result in the browse and the display names
	 *  @param initialValue is the initial variable value (also specifying the variable's type)
	 *  @param readOnly optional parameter to specify if the variably is read-only (from the client's perspective) or also with write access
	 *  @param namespaceId optional parameter to specify the namespace index
	 *
	 *  @return true if the variable has been created successfully of false otherwise
	 */
	bool addVariableNode(const std::string &nodeName, const OPCUA::Variant &initialValue, const bool &readOnly=true, const unsigned short &namespaceId=1);

	/** use this method from within createServerSpace() to add an OPC UA method to the internal server space
	 *
	 *  This method wraps the code to create and add a new OPC UA Method with its input and output arguments
	 *  to the internally created rootObject. The Method's arguments are specified using a map where the keys denote the argument names and
	 *  the values denote the data-types. Please note, that the Variant parts are only used to identify the data-type of the according
	 *  Method attribute. If you additionally provide initial values, these values will be ignored as this is currently
	 *  not supported by the underlying library.
	 *
	 *  @param methodBrowseName the name of the OPC UA Method which will result in the browse and the display names
	 *  @param inputArguments a map specifying the Method's input arguments (key=name, value=type)
	 *  @param outputArguments a map specifying the Method's output arguments (key=name, value=type)
	 *  @param namespaceId optional parameter to specify the namespace index
	 *
	 *  @return true if the OPC UA Method has been created successfully of false otherwise
	 */
	bool addMethodNode(const std::string &methodBrowseName,
			const std::map<std::string,Variant> &inputArguments,
			const std::map<std::string,Variant> &outputArguments,
			const unsigned short &namespaceId=1);

	/** overload and implement this method in derived classes to implement the server space
	 *
	 *  Please use the methods createRootObject(), addVariableNode() and addMethodNode() to define the server space.
	 *  This method is automatically called from within the method run()
	 *
	 *  @return true on success or false if something went wrong during initialization
	 *
	 *  @sa addVariableNode()
	 *  @sa addMethodNode()
	 */
	virtual bool createServerSpace();

	/** overload this method to get notified about read requests from a remote client for the provided variable name
	 *
	 *  This upcall handler is triggered each time the OPC UA variable (identified by the browseName) is read from a remote client.
	 *  In case the variable is read internally from within the server, this method is not called as this might easily
	 *  cause infinite loops. You can overload this method in derived classes to implement a specific behavior for
	 *  incoming read requests.
	 *
	 *  @param browseName the browse name of the OPC UA variable
	 *  @param value output argument receives the new value of the OPC UA variable
	 *
	 */
	virtual void handleOnRead(const std::string &browseName, Variant &value);

	/** overload this method to get notified about write requests from a remote client for the provided variable name
	 *
	 *  This upcall handler is triggered each time the OPC UA variable (identified by the browseName) is written from a remote client.
	 *  You can overload this method in derived classes to implement a specific behavior for incoming write requests.
	 *
	 *  @param browseName the browse name of the OPC UA variable
	 *  @param value the new value of the OPC UA variable
	 *
	 */
	virtual void handleOnWrite(const std::string &browseName, const Variant &value);

	/** overload this method to get notified about remote method calls from a remote client for the provided OPC UA Method name
	 *
	 *  This upcall handler is triggered each time the OPC UA Method (identified by the browseName) is called from a remote client.
	 *  You can overload this method in derived classes to implement a specific behavior for incoming method calls.
	 *
	 *  @param browseName the browse name of the OPC UA variable
	 *  @param inputs a vector of input-argument-values
	 *  @param outputs a reference to a vector to store the resulting output-argument-values
	 *
	 */
	virtual void handleMethodCall(const std::string &browseName, const std::vector<Variant> &inputs, std::vector<Variant> &outputs);

public:
	/** default constructor requires at the minimum a name for the root object that is automatically created
	 *
	 *  This constructor internally creates a new UA_Server and a server space with one root object
	 *  with the given name and namespace-ID. Optionally, the port-number for the UA_Server can be provided.
	 *
	 *  @param rootObjectName The browse noame of the root-object within the server-space
	 *  @param namespaceId optionally, the namespace ID for the browse-name can be given (default: 1)
	 *  @param portNr optional port number for the server to listen to (default: 4840)
	 *  @param activateSignalHandler optional parameter to activate/deactivate the default SIGINT signal handler (for stopping the server with CTRL+C)
	 *
	 */
	GenericServer(
		const std::string &rootObjectName,
		const unsigned short &namespaceId=1,
		const unsigned short &portNr=4840,
		const bool &activateSignalHandler=true
	);

	/// default destructor
	virtual ~GenericServer();

	/** use this method to write a new value to an internal variable identified by its browseName
	 *
	 *  This method can be used to activelly write a new value to an OPC UA Variable (identified by the browseName).
	 *
	 *  @param browseName the browse name of the OPC UA Variable to write the new value to
	 *  @param value the new value for the OPC UA Variable
	 *  @param namespaceId an optional namespace index (in case the variable is in a different index than 1)
	 */
	OPCUA::StatusCode writeVariable(const std::string &browseName, const OPCUA::Variant &value, const unsigned short &namespaceId=1);

	/** this method executes the internal OPC-UA server until CTRL-C is pressed
	 *
	 *  This method should be called from a new thread (or the main thread) to operate the
	 *  server-side infrastructure (like upcalls/events/etc.) This method blocks forever as long
	 *  as no CTR+C (i.e. the SIGINT) signal is pressed.
	 *
	 *  @return 0 if everything was fine or -1 otherwise
	 */
	int run();

	/** this method signals the server's internal run-loop to stop
	 *
	 *  The method run blocks indefinitely until either a CTR+C is pressed or
	 *  this method is called.
	 */
	void signalStop();
};

} /* namespace OPCUA */

#endif /* OPCUAGENERICSERVER_HH_ */
